## Replication code for "Understanding Managers' Trade-offs between Exploration and Exploitation"
# Author: Alina Ferecatu and Arnaud De Bruyn
# Date: April 2021
# Simulation study reported in Web Appendix WA6

## load required packages ----
rm(list=ls())
library(stargazer)
library(loo)
library(rstan)
library(tidyverse)
library(nnet)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

## Set paths ---- 
PATH_FUNCTION= "/data/learning_EEI" # "/set/local/path/here" 
PATH_DATA="/set/local/path/here"
PATH_RESULTS="/set/local/path/here"
PATH_PLOTS="/set/local/path/here"

## Source functions ----
source(paste0(PATH_FUNCTION,"/EEtradeoffs_functions.R") )

## Load experimental draws ----
exp_draws=read.csv(paste0(PATH_DATA, "/exp_draws_Study1.csv"), sep=",",header=T)
exp_draws =exp_draws%>% 
  filter(Set %in% c("set1", "set2","set3", "set4", "set5"))
exp_draws=exp_draws %>% group_by(Set) %>% 
  mutate(groupID=cur_group_id()) %>% 
  ungroup()

## Simulate Data - proposed EEI/EWA model ---
#* Parameters----
K=3
D=2
nvarWA=3
nvarHMM=K*(K-1)
nvarD=(D-1)*K
nvar=nvarWA+nvarHMM

phi_mean=-1.25 
rho_mean=0.8 
lambda1_mean=-2.5
lambda2_mean=0

pi0 = c(1, 0, 0)

betaHMM_mean=c(1.6, .4, -2.7, 1.2, -2.5, -1.4)
betaHMM_sd=c(1, 1, 0.25, 1, 1, .64)
betaD=c(1.4, 0.5, 0, 2.7, 1.2, 1.2)

## delta and vcov
Delta=c(betaHMM_mean, lambda2_mean, rho_mean, phi_mean)
Vbeta=diag(c(betaHMM_sd, .25, .04, .16))

#* Data for X and y -----
prior=50
N0=1
N_arms= 3
H=89                ## number of cross-sectional units
Nobs=100  					## number of observations per unit
Rounds=1:100
ID=sort(rep(1:H,Nobs))
u=rep(1, H) ## no psychometrics
set.seed(9000)
expSet_index=sample(1:5, H, replace=T)
## simulate states
strue=state_probs=NULL

## Observation eq.
obs_probs=ysim=Xsim=W_Average_simdata=NULL
y <- vector("numeric", Nobs)
X <- vector("numeric", Nobs)
W_Average_sim= probs=matrix( , ncol=N_arms, nrow=Nobs)

emprobs=matrix(, ncol=N_arms, nrow=Nobs)
Qij=matrix(, ncol=K, nrow=Nobs)
strue=state_probs=true_params=gl=NULL

for (h in 1:H){
  ## take an experimental set of draws
  Xdraws_h=as.matrix(exp_draws %>% 
    filter(groupID==expSet_index[h]) %>% 
    dplyr::select(A, B, C) )
  
  beta=as.vector(Delta)+(t(chol(Vbeta))%*%as.matrix(rnorm(nvar, 0, 1)))
  lambda_explore= inv_logit(lambda1_mean)
  lambda_exploit=inv_logit(lambda1_mean+exp(beta[7]))
  rho=inv_logit(beta[8])
  phi=inv_logit(beta[9])
  
  betaM=array(,dim=c(K,D,K))
  for(k in 1:K)
  {betaM[,,k]= matrix(c(beta[((k-1)*(K-1)+1):(k*(K-1))], 0, betaD[((k-1)*(K-1)+1):(k*(K-1))], 0), ncol=D)};
  # transition matrix and states
  sind=gl=vector("numeric", Nobs)
  sind[1]= sample(x = 1:K, size = 1, prob = pi0)
  trprobs=pi0
  
  ## draw a choice from p(y|explore)
  emprobs[1, ]=c(0.333333, 0.333333, 0.333334);
  
  ew=rep(N0, N_arms);
  W_Average=rep(prior, N_arms);
  y[1]=sample(x = 1:N_arms, size = 1, prob = emprobs[1, ])
  X[1]= Xdraws_h[1, y[1]] 
  gl[1]=ifelse(X[1]>prior, 0, 1);
  
  for (t in 2:Nobs) {
    XD=c(1, gl[t-1]);
    
    Qij[t, ] <- softmax(t(XD)%*%t(betaM[,,sind[t-1]]))
    sind[t] <- sample(x = 1:K, size = 1, prob = Qij[t, ])
    
    ew1=ew[y[t-1]];
    ew[y[t-1]]=rho*ew[y[t-1]]+1;
    W_Average[y[t-1]]=(phi*ew1*W_Average[y[t-1]]+X[t-1])/ew[y[t-1]];
    W_Average_sim[t,]=W_Average

    if(sind[t]==1) {
      ## State 1 - random;
      emprobs[t, ]=softmax(lambda_explore*W_Average)
    }else if (sind[t]==2) {     
      ## State 2 - exploitation;
      emprobs[t, ]=softmax(lambda_exploit*W_Average);
    }else{
      ## State 3 - inertia;
      emprobs[t, ]=rep(0.000025, N_arms);
      emprobs[t, y[t-1]]=0.99995
    }
    
    y[t]=sample(1:N_arms, size = 1, prob = emprobs[t, ])
    X[t]=Xdraws_h[t, y[t]]
    Xmean=mean(c(prior, X[1:(t-1)]))
    gl[t]=ifelse(X[t]>Xmean,0, 1);
    
  }
  
  ysim=c(ysim, y)
  Xsim=c(Xsim, X)
  obs_probs=rbind(obs_probs, emprobs)
  W_Average_simdata=rbind(W_Average_simdata, W_Average_sim)
  
  print(table(sind))
  strue=c(strue, sind)
  state_probs=rbind(state_probs, Qij)
  params=c(beta[1:6], lambda_explore, lambda_exploit, phi, rho)
  true_params=rbind(true_params, params)
}

# true state proportions
table(strue)/length(strue)
colMeans(true_params)

### Simdata  -----
simdata=tibble(userid=ID, Rounds=rep(Rounds, H), strue=strue,
               y=ysim, X=Xsim) %>%   
  mutate(lastT=ifelse(row_number()==n(), 1,0))

## Model estimation ----
##* Flags ----
## "eei_ewa_mixed" - EEI/EWA proposed model; "discountEV" - EEI/EWA discountEV, "eei_mixed_noEWA" - EEI
## "ee_only_ewa_mixed" - EE/EWA; "eei_stat_ewa" - statEEI/EWA; "ewa_only" - EWA; 
MODEL = "eei_mixed_noEWA"

if(MODEL=="eei_ewa_mixed"){
  stancode=hmme_eei_ewa_mixed
  m = stan_model(model_code = stancode)
}else if (MODEL=="discountEV"){ 
  stancode=hmme_eei_ewa_mixed_discountEV
  m = stan_model(model_code = stancode)
}else if (MODEL=="ee_only_ewa_mixed"){ 
  stancode=hmme_ee_only_ewa_mixed
  m = stan_model(model_code = stancode)
}else if (MODEL=="eei_mixed_noEWA"){ 
  stancode = hmme_eei_mixed_noEWA
  m = stan_model(model_code = stancode)
}else if (MODEL=="eei_stat_ewa"){ 
  stancode=hmme_eei_stationary_ewa
  m = stan_model(model_code = stancode)
}else{ 
  stancode=hmme_ewa_only
  m = stan_model(model_code = stancode)
}

if (MODEL=="ee_only_ewa_mixed"){ 
  pi0=c(0.99999, 0.00001)
  z=c(1, 2)
  K=2
}else{ 
  pi0=c(0.99999, 0.000005, 0.000005)
  z=c(1, 2, 3)
  K=3
}

### Stan dataset ----
u=as.matrix(rep(1, H)) 
ndem=ncol(u)

### stan dataset -----
stan.data = list(
  N=nrow(simdata), # number of observations
  H=H,             # number of individuals
  K=K,             # number of hidden states
  nvar_ind=3,
  N_arms=N_arms,   # number of possible choices 
  lastT=pull(simdata, lastT),  
  ID=pull(simdata, userid),     # vector of individual index
  y=pull(simdata, y),
  prior=rep(prior, N_arms),
  X=pull(simdata, X),
  T=pull(simdata, Rounds),
  D=2,
  pi0=pi0,
  N0=1,
  z=z,
  u=u,
  ndem=ncol(u)
)

## Run the model ----
Sim_EEI_EWA_stanfit<- stan(model_code = stancode, data = stan.data,
                    verbose = TRUE, chains = 2,
                    seed = 9000, iter =4000, warmup=3000, 
                    control = list(adapt_delta=0.99, max_treedepth=15))

#* export results ----
library(stargazer)
b=summary(Sim_EEI_EWA_stanfit, pars=c("gamma[1,1]", "gamma[1,2]", "gamma[1,3]", 
                                  "gamma[1,4]", "gamma[1,5]", "gamma[1,6]", "betaD", 
                                   "lambda_explore", "gamma[1,7]", "gamma[1,8]","gamma[1,9]", 
                                  "lambda_explore_unt"),
          probs=c(0.025, 0.975), digits=3)$summary
bsmall=b[,c(1, 4, 5)]
bsmall[15,]=inv_logit(bsmall[15,])
bsmall[16,]=inv_logit(bsmall[16,])

lambda_exploitCI=inv_logit(bsmall[17,]+exp(bsmall[14,]))
bsmall=rbind(bsmall, lambda_exploitCI)

btrue=c(betaHMM_mean, betaD, inv_logit(lambda1_mean), inv_logit(lambda1_mean), 
        inv_logit(rho_mean), inv_logit(phi_mean), inv_logit(lambda1_mean), 
        inv_logit(lambda1_mean+exp(lambda2_mean)))

stargazer(cbind(btrue, bsmall), summary = F, digits=3, digits.extra =0, align = T)

##* In-sample fit ----
insample=InSample_sims(stfit, simdata)
## log-pred density, WAIC, HR, MSE - reported in Table WA7
c(insample[[1]], insample[[2]], insample[[3]], insample[[4]])

## State recovery analysis
zestimated= insample[[6]]
## percentages reported in Table WA8 
table(strue)/length(ztrue)
table(c(zestimated))/length(c(zestimated))
